import { build as viteBuild } from 'vite';
import { viteSingleFile } from 'vite-plugin-singlefile';
import { resolve } from 'path';
import { createHash } from 'node:crypto';
import fs from 'fs/promises';
import { existsSync } from 'fs';
import { rmSync } from 'fs';

const PROJECT_ROOT = process.cwd();
console.log('Project root:', PROJECT_ROOT);
const SERVER_DIR = resolve(PROJECT_ROOT, 'dist'); // carpeta de destino para Apps Script
const TEMP_ROOT = resolve(PROJECT_ROOT, '.vite_tmp'); // temp builds
const CACHE_FILE = resolve(SERVER_DIR, '.build-cache.json');

// --- CLI flags
// --pages=home,dashboard   -> compila solo esas páginas
// --changed                -> compila solo páginas (y opcionalmente servidor) que hayan cambiado
// --skip-server            -> no compila el servidor
const ARGS = process.argv.slice(2);
const getArgVal = (key) => {
	const prefix = key + '=';
	const found = ARGS.find((a) => a.startsWith(prefix));
	return found ? found.slice(prefix.length) : undefined;
};
const PAGES_ARG = getArgVal('--pages');
const ONLY_CHANGED = ARGS.includes('--changed');
const SKIP_SERVER = ARGS.includes('--skip-server');

// --- Descubre entradas dinámicamente: escanea src/client/pages en busca de carpetas que contengan index.html
async function discoverEntries() {
	const pagesRoot = resolve(PROJECT_ROOT, 'src/client/pages');
	const list = [];
	try {
		const dirents = await fs.readdir(pagesRoot, { withFileTypes: true });
		for (const d of dirents) {
			if (!d.isDirectory()) continue;
			const name = d.name;
			const indexPath = resolve(pagesRoot, name, 'index.html');
			try {
				await fs.stat(indexPath);
				list.push({ name, html: indexPath });
			} catch (e) {
				try {
					const appTsx = resolve(pagesRoot, name, 'App.tsx');
					await fs.stat(appTsx);
					// No hay index.html, pero sí App.tsx — lo permitimos y usaremos una plantilla compartida
					list.push({ name, html: null });
				} catch (e2) {
					continue;
				}
			}
		}
	} catch (err) {
		console.error('Error discovering pages in', pagesRoot, err);
	}
	// ordenar alfabéticamente por nombre para un orden de compilación determinista
	return list.sort((a, b) => a.name.localeCompare(b.name));
}

// Archivo server (Apps Script) — entry para la lógica de servidor (Apps Script)
const serverEntry = resolve(PROJECT_ROOT, 'src/server/index.ts');

async function ensureServerDir() {
	if (!existsSync(SERVER_DIR)) {
		await fs.mkdir(SERVER_DIR, { recursive: true });
	}
}

async function buildServer() {
	console.log('Building server code (Apps Script) -> dist/Code.js ...');
	await viteBuild({
		build: {
			emptyOutDir: false,
			outDir: resolve(PROJECT_ROOT, 'temp_server_build'),
			sourcemap: false,
			minify: false,
			lib: {
				entry: serverEntry,
				formats: ['iife'],
				name: 'globalThis',
				fileName: 'Code',
			},
			rollupOptions: {
				output: {
					entryFileNames: 'Code.js',
					extend: true,
				},
			},
		},
		configFile: resolve(PROJECT_ROOT, 'vite.config.ts'),
	});

	const tmp = resolve(PROJECT_ROOT, 'temp_server_build', 'Code.js');
	const dest = resolve(SERVER_DIR, 'Code.js');
	await ensureServerDir();

	try {
		let content = await fs.readFile(tmp, 'utf-8');
		// Elimina el envoltorio IIFE y las exportaciones para obtener solo funciones planas para Apps Script
		const match = content.match(/^\(function\s*\(exports\)\s*\{\s*('use strict'|"use strict");?([\s\S]*)\}\)\(this\.globalThis/);

		if (match && match[2]) {
			let innerContent = match[2];
			let functionsOnly = innerContent
				.replace(/exports\.\w+\s*=\s*\w+;/g, '')
				.replace(/Object\.defineProperty\(exports,[\s\S]*\);/g, '')
				.trim();

			await fs.writeFile(dest, functionsOnly, 'utf-8');
			console.log(`  -> dist/Code.js created (transformed for Apps Script)`);
		} else {
			console.warn('Could not transform server code, writing original. It may not work in Apps Script.');
			await fs.copyFile(tmp, dest);
		}
	} catch (err) {
		console.error('Error processing server Code.js:', err);
		process.exit(1);
	} finally {
		try {
			rmSync(resolve(PROJECT_ROOT, 'temp_server_build'), { recursive: true, force: true });
		} catch (e) {}
	}
}

// Genera src/server/doGet.generated.ts con condiciones para cada página
async function writeDoGetGenerated(pageNames) {
	const serverSrcDir = resolve(PROJECT_ROOT, 'src', 'server');
	try {
		await fs.mkdir(serverSrcDir, { recursive: true });
	} catch (e) {}

	const pages = pageNames;
	const defaultPage = pages.includes('home') ? 'home' : pages[0] || 'home';

	let body = '';
	for (const p of pages) {
		body += `  if (page === '${p}') {\n    return HtmlService.createHtmlOutputFromFile('${p}');\n  }\n`;
	}

	const content = `// GENERATED by scripts/build-apps.mjs - do not edit\nexport function doGet(e: GoogleAppsScript.Events.DoGet): GoogleAppsScript.HTML.HtmlOutput {\n  const page = e && e.parameter && e.parameter.page ? String(e.parameter.page).trim() : '';\n\n${body}\n  return HtmlService.createHtmlOutputFromFile('${defaultPage}');\n}\n`;

	const outPath = resolve(serverSrcDir, 'doGet.generated.ts');
	await fs.writeFile(outPath, content, 'utf-8');
	console.log('  -> src/server/doGet.generated.ts written');
}

// busca recursivamente el primer .html dentro de una carpeta
async function findHtmlFile(dir) {
	try {
		const entries = await fs.readdir(dir, { withFileTypes: true });
		for (const e of entries) {
			const full = resolve(dir, e.name);
			if (e.isFile() && full.toLowerCase().endsWith('.html')) return full;
			if (e.isDirectory()) {
				const found = await findHtmlFile(full);
				if (found) return found;
			}
		}
	} catch (err) {
		return null;
	}
	return null;
}

async function buildClientSingleFile(entry) {
	console.log(`\nBuilding client single-file: ${entry.name} ...`);
	const outDir = resolve(TEMP_ROOT, entry.name);
	const tempPageDir = resolve(TEMP_ROOT, entry.name, 'page');

	// limpia temp por si acaso
	try {
		rmSync(outDir, { recursive: true, force: true });
	} catch (e) {}

	// Crear carpeta temporal para esta página y generar un main.tsx que importe el App de la página
	try {
		await fs.mkdir(tempPageDir, { recursive: true });
		const sharedTemplatePath = resolve(PROJECT_ROOT, 'src/client/template.html');
		let indexContent;
		if (!entry.html) {
			if (!existsSync(sharedTemplatePath)) {
				console.error(`No index.html for page "${entry.name}" and no shared template at ${sharedTemplatePath}.`);
				process.exit(1);
			}
			indexContent = await fs.readFile(sharedTemplatePath, 'utf-8');
			indexContent = indexContent.replace(/{{PAGE_NAME}}/g, entry.name);
			indexContent = indexContent.replace(/{{TITLE}}/g, entry.name);
		} else {
			indexContent = await fs.readFile(entry.html, 'utf-8');
		}

		await fs.writeFile(resolve(tempPageDir, 'index.html'), indexContent, 'utf-8');
		// generar main.tsx dinámico que use el alias '@' para importar App y CSS
		// Debug: nombre de página
		console.log(entry.name);
		const genMain = `import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport '@/client/index.css';\nimport App from '@/client/pages/${entry.name}/App';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n`;
		await fs.writeFile(resolve(tempPageDir, 'main.tsx'), genMain, 'utf-8');
	} catch (e) {
		console.error('Error preparing temporary page files for', entry.name, e);
		process.exit(1);
	}

	// configuración por entrada: heredamos vite.config.js (alias/plugins) usando configFile, pero también forzamos outDir e input al index.html temporal
	const configForEntry = {
		plugins: [viteSingleFile({ useRecommendedBuildConfig: true })],
		build: {
			outDir,
			emptyOutDir: true,
			rollupOptions: {
				input: resolve(tempPageDir, 'index.html'),
			},
			minify: true,
			sourcemap: false,
		},
		configFile: resolve(PROJECT_ROOT, 'vite.config.ts'),
	};

	try {
		await viteBuild(configForEntry);
	} catch (err) {
		console.error(`Error building ${entry.name}:`, err);
		process.exit(1);
	}

	const generatedIndex = await findHtmlFile(outDir);
	if (!generatedIndex) {
		console.error(`\n⚠️ No se encontró ningún .html en ${outDir} después del build.`);
		try {
			const list = await fs.readdir(outDir);
			console.error('Contenido de la carpeta temporal:', list);
		} catch (e) {
			console.error('No se pudo leer la carpeta temporal:', e.message || e);
		}
		console.error('Asegúrate de que la entrada HTML existe y que el build produjo archivos. Saliendo.');
		process.exit(1);
	}

	const targetHtml = resolve(SERVER_DIR, `${entry.name}.html`);

	try {
		const content = await fs.readFile(generatedIndex, 'utf-8');
		await ensureServerDir();
		await fs.writeFile(targetHtml, content, 'utf-8');
		console.log(`  -> dist/${entry.name}.html written (desde ${generatedIndex})`);
	} catch (err) {
		console.error(`Error writing server/${entry.name}.html:`, err);
		process.exit(1);
	} finally {
		try {
			rmSync(outDir, { recursive: true, force: true });
		} catch (e) {}
	}
}

// Utilidades de hashing para compilación incremental
async function walkFiles(dir) {
	const out = [];
	try {
		const entries = await fs.readdir(dir, { withFileTypes: true });
		for (const e of entries) {
			const full = resolve(dir, e.name);
			if (e.isDirectory()) {
				const nested = await walkFiles(full);
				out.push(...nested);
			} else {
				out.push(full);
			}
		}
	} catch {}
	return out;
}

async function hashFiles(files) {
	const h = createHash('sha1');
	for (const f of files.sort()) {
		try {
			const buf = await fs.readFile(f);
			h.update(f);
			h.update(buf);
		} catch {}
	}
	return h.digest('hex');
}

async function computePageHash(pageName) {
	const pageDir = resolve(PROJECT_ROOT, 'src/client/pages', pageName);
	const files = await walkFiles(pageDir);
	// Considera archivos típicos
	const filtered = files.filter((f) => /\.(tsx?|jsx?|html|css|json)$/.test(f));
	return await hashFiles(filtered);
}

async function computeServerHash() {
	const serverDir = resolve(PROJECT_ROOT, 'src/server');
	const files = await walkFiles(serverDir);
	const filtered = files.filter((f) => /\.(ts|js|json)$/.test(f));
	return await hashFiles(filtered);
}

async function loadCache() {
	try {
		const txt = await fs.readFile(CACHE_FILE, 'utf-8');
		return JSON.parse(txt);
	} catch {
		return { pages: {}, server: '' };
	}
}

async function saveCache(cache) {
	try {
		await ensureServerDir();
		await fs.writeFile(CACHE_FILE, JSON.stringify(cache, null, 2), 'utf-8');
	} catch {}
}

(async () => {
	console.log('Starting Apps Script build (server + single-file clients)...');

	await ensureServerDir();

	let entries = await discoverEntries();
	// Filtra por --pages si se pasa
	if (PAGES_ARG) {
		const allow = new Set(
			PAGES_ARG.split(',')
				.map((s) => s.trim())
				.filter(Boolean),
		);
		entries = entries.filter((e) => allow.has(e.name));
	}
	console.log('Discovered pages:', entries.map((e) => e.name).join(', ') || '(none)');

	// Generate pages manifest (src/server/pages.generated.ts)
	try {
		const pageNames = entries.map((e) => e.name);
		const serverSrcDir = resolve(PROJECT_ROOT, 'src', 'server');
		await fs.mkdir(serverSrcDir, { recursive: true });
		const pagesContent = `// GENERATED by scripts/build-apps.mjs - do not edit\nexport const PAGES = ${JSON.stringify(
			pageNames,
			null,
			2,
		)} as const;\nexport type Page = typeof PAGES[number];\n`;
		await fs.writeFile(resolve(serverSrcDir, 'pages.generated.ts'), pagesContent, 'utf-8');
		console.log('  -> src/server/pages.generated.ts written');
		// Generate doGet implementation
		await writeDoGetGenerated(pageNames);
	} catch (e) {
		console.error('Error writing server generated files:', e);
		process.exit(1);
	}

	// Build server con cache si no se pasa --skip-server
	const cache = await loadCache();
	if (!SKIP_SERVER) {
		const newServerHash = await computeServerHash();
		const hasServerChanged = cache.server !== newServerHash;
		if (!ONLY_CHANGED || hasServerChanged) {
			await buildServer();
			cache.server = newServerHash;
		} else {
			console.log('Skipping server build (no changes detected)');
		}
	} else {
		console.log('Skipping server build due to --skip-server flag');
	}

	// Determinar qué páginas compilar
	const pagesToBuild = [];
	for (const entry of entries) {
		if (entry.html) {
			if (!existsSync(entry.html)) {
				console.warn(`Warning: entry html not found: ${entry.html} — skipping`);
				continue;
			}
		} else {
			console.log(`Note: page "${entry.name}" has no index.html; using shared template (if present).`);
		}
		let shouldBuild = true;
		if (ONLY_CHANGED) {
			const newHash = await computePageHash(entry.name);
			const prevHash = cache.pages?.[entry.name];
			if (prevHash && prevHash === newHash && existsSync(resolve(SERVER_DIR, `${entry.name}.html`))) {
				shouldBuild = false;
			} else {
				// registrar el nuevo hash antes o después
				cache.pages = cache.pages || {};
				cache.pages[entry.name] = newHash;
			}
		}
		if (shouldBuild) pagesToBuild.push(entry);
	}

	if (pagesToBuild.length === 0) {
		console.log('No pages to build (either filtered by --pages or unchanged with --changed).');
	} else {
		for (const entry of pagesToBuild) {
			await buildClientSingleFile(entry);
		}
	}

	// 3) Copiar appsscript.json (si tienes una plantilla local)
	const appsscriptSrc = resolve(PROJECT_ROOT, 'appsscript.json');
	const appsscriptDest = resolve(SERVER_DIR, 'appsscript.json');
	if (existsSync(appsscriptSrc)) {
		await fs.copyFile(appsscriptSrc, appsscriptDest);
		console.log('  -> appsscript.json copied to server/');
	} else {
		console.log('  -> No local appsscript.json found (skipping copy).');
	}

	try {
		rmSync(TEMP_ROOT, { recursive: true, force: true });
	} catch (e) {}

	// Guardar cache
	await saveCache(cache);

	console.log('\nBuild finished. Result files in /dist (list):');
	const files = await fs.readdir(SERVER_DIR);
	files.forEach((f) => console.log('  -', f));
	console.log('\nPuedes ejecutar: clasp push (desde la carpeta dist) o configurar tu workflow.');
})();
