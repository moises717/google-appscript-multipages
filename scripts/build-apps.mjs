// build-apps.mjs (versión robusta)
import { build as viteBuild } from 'vite';
import { viteSingleFile } from 'vite-plugin-singlefile';
import { resolve } from 'path';
import fs from 'fs/promises';
import { existsSync } from 'fs';
import { rmSync } from 'fs';

const PROJECT_ROOT = process.cwd();
console.log('Project root:', PROJECT_ROOT);
const SERVER_DIR = resolve(PROJECT_ROOT, 'dist'); // carpeta de destino para Apps Script
const TEMP_ROOT = resolve(PROJECT_ROOT, '.vite_tmp'); // temp builds

// --- Discover entries dynamically: scan src/client/pages for folders that contain index.html
async function discoverEntries() {
	const pagesRoot = resolve(PROJECT_ROOT, 'src/client/pages');
	const list = [];
	try {
		const dirents = await fs.readdir(pagesRoot, { withFileTypes: true });
		for (const d of dirents) {
			if (!d.isDirectory()) continue;
			const name = d.name;
			const indexPath = resolve(pagesRoot, name, 'index.html');
			try {
				// fs.access via promises doesn't exist in fs/promises on older Node, use stat via promises
				await fs.stat(indexPath);
				list.push({ name, html: indexPath });
			} catch (e) {
				// no index.html — still consider the folder if it contains an App.tsx (we'll use shared template)
				try {
					const appTsx = resolve(pagesRoot, name, 'App.tsx');
					await fs.stat(appTsx);
					// add entry without html (will use template)
					list.push({ name, html: null });
				} catch (e2) {
					// no App.tsx either — skip
					continue;
				}
			}
		}
	} catch (err) {
		console.error('Error discovering pages in', pagesRoot, err);
	}
	// sort alphabetically by name for deterministic build order
	return list.sort((a, b) => a.name.localeCompare(b.name));
}

// Archivo server (Apps Script) — entry para la lógica de servidor (Apps Script)
const serverEntry = resolve(PROJECT_ROOT, 'src/server/index.ts');

async function ensureServerDir() {
	if (!existsSync(SERVER_DIR)) {
		await fs.mkdir(SERVER_DIR, { recursive: true });
	}
}

async function buildServer() {
	console.log('Building server code (Apps Script) -> dist/Code.js ...');
	await viteBuild({
		build: {
			emptyOutDir: false,
			outDir: resolve(PROJECT_ROOT, 'temp_server_build'),
			sourcemap: false,
			minify: false,
			lib: {
				entry: serverEntry,
				formats: ['iife'],
				name: 'globalThis',
				fileName: 'Code',
			},
			rollupOptions: {
				output: {
					entryFileNames: 'Code.js',
					extend: true,
				},
			},
		},
		configFile: resolve(PROJECT_ROOT, 'vite.config.js'),
	});

	const tmp = resolve(PROJECT_ROOT, 'temp_server_build', 'Code.js');
	const dest = resolve(SERVER_DIR, 'Code.js');
	await ensureServerDir();

	try {
		let content = await fs.readFile(tmp, 'utf-8');
		// Strip IIFE wrapper and exports to get plain functions for Apps Script
		const match = content.match(
			/^\(function\s*\(exports\)\s*\{\s*('use strict'|"use strict");?([\s\S]*)\}\)\(this\.globalThis/
		);

		if (match && match[2]) {
			let innerContent = match[2];
			let functionsOnly = innerContent
				.replace(/exports\.\w+\s*=\s*\w+;/g, '')
				.replace(/Object\.defineProperty\(exports,[\s\S]*\);/g, '')
				.trim();

			await fs.writeFile(dest, functionsOnly, 'utf-8');
			console.log(`  -> server/Code.js created (transformed for Apps Script)`);
		} else {
			console.warn('Could not transform server code, writing original. It may not work in Apps Script.');
			await fs.copyFile(tmp, dest);
		}
	} catch (err) {
		console.error('Error processing server Code.js:', err);
		process.exit(1);
	} finally {
		try {
			rmSync(resolve(PROJECT_ROOT, 'temp_server_build'), { recursive: true, force: true });
		} catch (e) {}
	}
}

// Genera src/server/doGet.generated.ts con condiciones por página
async function writeDoGetGenerated(pageNames) {
	const serverSrcDir = resolve(PROJECT_ROOT, 'src', 'server');
	try {
		await fs.mkdir(serverSrcDir, { recursive: true });
	} catch (e) {}

	const pages = pageNames;
	const defaultPage = pages.includes('home') ? 'home' : pages[0] || 'home';

	let body = '';
	for (const p of pages) {
		body += `  if (page === '${p}') {\n    return HtmlService.createHtmlOutputFromFile('${p}');\n  }\n`;
	}

	const content = `// GENERATED by scripts/build-apps.mjs - do not edit\nexport function doGet(e: GoogleAppsScript.Events.DoGet): GoogleAppsScript.HTML.HtmlOutput {\n  const page = e && e.parameter && e.parameter.page ? String(e.parameter.page).trim() : '';\n\n${body}\n  return HtmlService.createHtmlOutputFromFile('${defaultPage}');\n}\n`;

	const outPath = resolve(serverSrcDir, 'doGet.generated.ts');
	await fs.writeFile(outPath, content, 'utf-8');
	console.log('  -> src/server/doGet.generated.ts written');
}

// busca recursivamente el primer .html dentro de una carpeta
async function findHtmlFile(dir) {
	try {
		const entries = await fs.readdir(dir, { withFileTypes: true });
		for (const e of entries) {
			const full = resolve(dir, e.name);
			if (e.isFile() && full.toLowerCase().endsWith('.html')) return full;
			if (e.isDirectory()) {
				const found = await findHtmlFile(full);
				if (found) return found;
			}
		}
	} catch (err) {
		return null;
	}
	return null;
}

async function buildClientSingleFile(entry) {
	console.log(`\nBuilding client single-file: ${entry.name} ...`);
	const outDir = resolve(TEMP_ROOT, entry.name);
	const tempPageDir = resolve(TEMP_ROOT, entry.name, 'page');

	// limpia temp por si acaso
	try {
		rmSync(outDir, { recursive: true, force: true });
	} catch (e) {}

	// Crear carpeta temporal para esta página y generar un main.tsx que importe el App de la página
	try {
		await fs.mkdir(tempPageDir, { recursive: true });
		// Si existe una plantilla compartida en src/client/template.html la usamos
		const sharedTemplatePath = resolve(PROJECT_ROOT, 'src/client/template.html');
		let indexContent;
		if (!entry.html) {
			// no hay index.html por página -> debemos usar la plantilla compartida
			if (!existsSync(sharedTemplatePath)) {
				console.error(`No index.html for page "${entry.name}" and no shared template at ${sharedTemplatePath}.`);
				process.exit(1);
			}
			indexContent = await fs.readFile(sharedTemplatePath, 'utf-8');
			indexContent = indexContent.replace(/{{PAGE_NAME}}/g, entry.name);
			indexContent = indexContent.replace(/{{TITLE}}/g, entry.name);
		} else {
			// copiar index.html de la página al temp (manteniendo script src="./main.tsx")
			indexContent = await fs.readFile(entry.html, 'utf-8');
		}
		// escribimos el index temporal
		await fs.writeFile(resolve(tempPageDir, 'index.html'), indexContent, 'utf-8');
		// generar main.tsx dinámico que use el alias '@' para importar App y CSS
		console.log(entry.name);
		const genMain = `import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport '@/client/index.css';\nimport App from '@/client/pages/${entry.name}/App';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n`;
		await fs.writeFile(resolve(tempPageDir, 'main.tsx'), genMain, 'utf-8');
	} catch (e) {
		console.error('Error preparing temporary page files for', entry.name, e);
		process.exit(1);
	}

	// configuración por entrada: heredamos vite.config.js (alias/plugins) usando configFile,
	// pero también forzamos outDir e input al index.html temporal
	const configForEntry = {
		plugins: [viteSingleFile({ useRecommendedBuildConfig: true })],
		build: {
			outDir,
			emptyOutDir: true,
			rollupOptions: {
				input: resolve(tempPageDir, 'index.html'),
			},
			minify: true,
			sourcemap: false,
		},
		configFile: resolve(PROJECT_ROOT, 'vite.config.js'),
	};

	try {
		await viteBuild(configForEntry);
	} catch (err) {
		console.error(`Error building ${entry.name}:`, err);
		process.exit(1);
	}

	// ahora buscamos cualquier .html generado dentro de outDir (no asumimos index.html)
	const generatedIndex = await findHtmlFile(outDir);
	if (!generatedIndex) {
		// listamos contenidos para debug
		console.error(`\n⚠️ No se encontró ningún .html en ${outDir} después del build.`);
		try {
			const list = await fs.readdir(outDir);
			console.error('Contenido de la carpeta temporal:', list);
		} catch (e) {
			console.error('No se pudo leer la carpeta temporal:', e.message || e);
		}
		console.error('Asegúrate de que la entrada HTML existe y que el build produjo archivos. Saliendo.');
		process.exit(1);
	}

	const targetHtml = resolve(SERVER_DIR, `${entry.name}.html`);

	try {
		const content = await fs.readFile(generatedIndex, 'utf-8');
		await ensureServerDir();
		await fs.writeFile(targetHtml, content, 'utf-8');
		console.log(`  -> server/${entry.name}.html written (desde ${generatedIndex})`);
	} catch (err) {
		console.error(`Error writing server/${entry.name}.html:`, err);
		process.exit(1);
	} finally {
		try {
			rmSync(outDir, { recursive: true, force: true });
		} catch (e) {}
	}
}

(async () => {
	console.log('Starting Apps Script build (server + single-file clients)...');

	await ensureServerDir();

	// Discover pages first so we can generate server helpers
	const entries = await discoverEntries();
	console.log('Discovered pages:', entries.map(e => e.name).join(', ') || '(none)');

	// Generate pages manifest (src/server/pages.generated.ts)
	try {
		const pageNames = entries.map(e => e.name);
		const serverSrcDir = resolve(PROJECT_ROOT, 'src', 'server');
		await fs.mkdir(serverSrcDir, { recursive: true });
		const pagesContent = `// GENERATED by scripts/build-apps.mjs - do not edit\nexport const PAGES = ${JSON.stringify(
			pageNames,
			null,
			2,
		)} as const;\nexport type Page = typeof PAGES[number];\n`;
		await fs.writeFile(resolve(serverSrcDir, 'pages.generated.ts'), pagesContent, 'utf-8');
		console.log('  -> src/server/pages.generated.ts written');
		// Generate doGet implementation
		await writeDoGetGenerated(pageNames);
	} catch (e) {
		console.error('Error writing server generated files:', e);
		process.exit(1);
	}

	// 1) Build server code now (includes generated manifest and doGet)
	await buildServer();

	// 2) Build each client single-file (one by one)
	for (const entry of entries) {
		if (entry.html) {
			if (!existsSync(entry.html)) {
				console.warn(`Warning: entry html not found: ${entry.html} — skipping`);
				continue;
			}
		} else {
			console.log(`Note: page "${entry.name}" has no index.html; using shared template (if present).`);
		}
		await buildClientSingleFile(entry);
	}

	// 3) Copy appsscript.json (si tienes una plantilla local)
	const appsscriptSrc = resolve(PROJECT_ROOT, 'appsscript.json');
	const appsscriptDest = resolve(SERVER_DIR, 'appsscript.json');
	if (existsSync(appsscriptSrc)) {
		await fs.copyFile(appsscriptSrc, appsscriptDest);
		console.log('  -> appsscript.json copied to server/');
	} else {
		console.log('  -> No local appsscript.json found (skipping copy).');
	}

	try {
		rmSync(TEMP_ROOT, { recursive: true, force: true });
	} catch (e) {}

	console.log('\nBuild finished. Result files in /server (list):');
	const files = await fs.readdir(SERVER_DIR);
	files.forEach(f => console.log('  -', f));
	console.log('\nAhora puedes ejecutar: clasp push (desde la carpeta server) o configurar tu workflow.');
})();
